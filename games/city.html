<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>God View: A* Pathfinding City v3.0</title>
    <style>
        :root {
            --bg: #0f172a;
            --panel: #1e293b;
            --accent: #38bdf8;
            --text: #f1f5f9;
        }
        body { margin: 0; background: var(--bg); color: var(--text); font-family: 'Segoe UI', Tahoma, sans-serif; display: flex; height: 100vh; overflow: hidden; }
        
        /* ä¾§è¾¹æ é¢æ¿ */
        #sidebar { width: 320px; background: var(--panel); border-right: 1px solid #334155; padding: 25px; display: flex; flex-direction: column; box-shadow: 10px 0 30px rgba(0,0,0,0.5); z-index: 10; }
        h1 { font-size: 24px; margin: 0 0 20px 0; background: linear-gradient(90deg, #38bdf8, #818cf8); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        
        .stat-group { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px; }
        .stat-card { background: #0f172a; padding: 12px; border-radius: 12px; border: 1px solid #334155; }
        .stat-label { font-size: 11px; color: #94a3b8; display: block; margin-bottom: 4px; }
        .stat-val { font-family: 'Courier New', monospace; font-size: 18px; font-weight: bold; color: var(--accent); }

        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        button { padding: 12px; border: 1px solid #334155; cursor: pointer; border-radius: 8px; background: #1e293b; color: white; transition: 0.2s; font-size: 13px; font-weight: 500; }
        button:hover { background: #334155; border-color: var(--accent); }
        button.active { background: var(--accent); color: #0f172a; border-color: white; box-shadow: 0 0 15px rgba(56, 189, 248, 0.4); }

        canvas { flex-grow: 1; background: #020617; }

        /* èœå•é®ç½© */
        #overlay { position: fixed; inset: 0; background: rgba(2, 6, 23, 0.95); display: flex; align-items: center; justify-content: center; z-index: 100; backdrop-filter: blur(5px); }
        .menu { background: var(--panel); padding: 50px; border-radius: 24px; text-align: center; border: 1px solid #334155; box-shadow: 0 20px 50px rgba(0,0,0,0.5); }
        .diff-btn { display: block; width: 220px; padding: 16px; margin: 12px auto; font-size: 16px; border: none; font-weight: bold; }

        #inspector { margin-top: 25px; padding: 15px; background: rgba(15, 23, 42, 0.6); border-radius: 12px; border: 1px solid #334155; min-height: 120px; }
    </style>
</head>
<body>

<div id="overlay">
    <div class="menu">
        <h1>CITY ARCHITECT v3.0</h1>
        <p style="color:#94a3b8">ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®è¿›å…¥ä¸Šå¸è§†è§’</p>
        <button class="diff-btn" style="background:#10b981; color:white;" onclick="startGame(2000)">ğŸ—ï¸ è½»æ¾å»ºè®¾</button>
        <button class="diff-btn" style="background:#3b82f6; color:white;" onclick="startGame(1000)">ğŸ™ï¸ æ ‡å‡†ç»è¥</button>
        <button class="diff-btn" style="background:#ef4444; color:white;" onclick="startGame(500)">ğŸŒ‹ æé™ç”Ÿå­˜</button>
    </div>
</div>

<div id="sidebar">
    <h1>CITY OS</h1>
    <div class="stat-group">
        <div class="stat-card"><span class="stat-label">ğŸ’° èµ„é‡‘</span><span class="stat-val" id="m-val">0</span></div>
        <div class="stat-card"><span class="stat-label">ğŸ‘¥ äººå£</span><span class="stat-val" id="p-val">0</span></div>
        <div class="stat-card"><span class="stat-label">ğŸ é£Ÿç‰©</span><span class="stat-val" id="f-val">0</span></div>
        <div class="stat-card"><span class="stat-label">ğŸ˜Š å¹¸ç¦åº¦</span><span class="stat-val" id="h-val">100%</span></div>
    </div>
    
    <div class="btn-grid">
        <button onclick="setTool(this, 'house')" class="active">ğŸ  ä½å®…åŒº</button>
        <button onclick="setTool(this, 'shop')">ğŸ›’ å•†ä¸šä¸­å¿ƒ</button>
        <button onclick="setTool(this, 'farm')">ğŸŒ¾ å·¥ä¸šå†œåœº</button>
        <button onclick="setTool(this, 'hospital')">ğŸ¥ ç»¼åˆåŒ»é™¢</button>
        <button onclick="setTool(this, 'fire')">ğŸš’ æ¶ˆé˜²æ€»ç«™</button>
        <button onclick="setTool(this, 'delete')" style="grid-column: span 2; background:#334155;">ğŸ”¨ æ‹†é™¤ä¸æ¨å¹³</button>
    </div>

    <div id="inspector">
        <div style="color:#94a3b8; font-size:12px;">è§‚å¯Ÿçª—ï¼šæœªé”å®šç›®æ ‡</div>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * CITY ARCHITECT v3.0 - A* å¼•æ“ç‰ˆ
 */

const TILE = 40;
const GRID_W = 30, GRID_H = 25;
const COLORS = {
    house: '#10b981', shop: '#3b82f6', farm: '#f59e0b',
    hospital: '#ef4444', fire: '#f97316', road: '#334155'
};

let game = {
    money: 0, food: 100, tick: 0,
    grid: [], // 0:ç©º, 1:å»ºç­‘, 2:é“è·¯
    buildings: [], agents: [],
    tool: 'house', active: false
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- è·¯å¾„æœç´¢ç®—æ³• (A-Star ç®€åŒ–ç‰ˆ) ---
function findPath(sx, sy, tx, ty) {
    let openList = [{x: sx, y: sy, g: 0, h: Math.abs(sx-tx)+Math.abs(sy-ty), p: null}];
    let closedList = new Set();
    
    while(openList.length > 0) {
        openList.sort((a,b) => (a.g+a.h) - (b.g+b.h));
        let curr = openList.shift();
        if(curr.x === tx && curr.y === ty) {
            let path = [];
            while(curr) { path.push({x: curr.x, y: curr.y}); curr = curr.p; }
            return path.reverse();
        }
        closedList.add(`${curr.x},${curr.y}`);
        
        [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx,dy]) => {
            let nx = curr.x+dx, ny = curr.y+dy;
            if(nx>=0 && nx<GRID_W && ny>=0 && ny<GRID_H && !closedList.has(`${nx},${ny}`)) {
                // åªæœ‰ç©ºæ ¼å­æˆ–é“è·¯å¯ä»¥é€šè¡Œï¼Œä¸èƒ½ç©¿è¿‡å»ºç­‘
                if(game.grid[ny][nx] !== 1 || (nx === tx && ny === ty)) {
                    let g = curr.g + (game.grid[ny][nx] === 2 ? 0.5 : 1); // é“è·¯é€šè¡Œä»£ä»·æ›´ä½
                    let existing = openList.find(o => o.x === nx && o.y === ny);
                    if(!existing) openList.push({x: nx, y: ny, g: g, h: Math.abs(nx-tx)+Math.abs(ny-ty), p: curr});
                }
            }
        });
    }
    return null; // æ— è·¯å¯èµ°
}

// --- å¯åŠ¨é€»è¾‘ ---
function startGame(money) {
    game.money = money;
    document.getElementById('overlay').style.display = 'none';
    for(let y=0; y<GRID_H; y++) {
        game.grid[y] = [];
        for(let x=0; x<GRID_W; x++) game.grid[y][x] = 0;
    }
    game.active = true;
    loop();
    setInterval(updateLogic, 100);
}

function setTool(btn, type) {
    game.tool = type;
    document.querySelectorAll('.btn-grid button').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
}

// --- å°äºº AI ---
class Agent {
    constructor(hx, hy) {
        this.hx = hx; this.hy = hy;
        this.x = hx * TILE + 20; this.y = hy * TILE + 20;
        this.path = [];
        this.speed = 2.5; // å¤§å¹…æå‡é€Ÿåº¦
        this.stats = { money: 10, health: 100, happy: 100, age: 0 };
        this.personality = { lazy: Math.random()>0.7, shopper: Math.random()>0.5 };
        this.state = 'idle'; 
        this.timer = 0;
    }

    update() {
        if(this.path.length > 0) {
            let target = this.path[0];
            let tx = target.x * TILE + 20;
            let ty = target.y * TILE + 20;
            let dx = tx - this.x;
            let dy = ty - this.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            
            // é“è·¯åŠ é€Ÿ
            let currentGridX = Math.floor(this.x/TILE);
            let currentGridY = Math.floor(this.y/TILE);
            let s = (game.grid[currentGridY] && game.grid[currentGridY][currentGridX] === 2) ? this.speed * 1.5 : this.speed;

            if(dist < s) {
                this.x = tx; this.y = ty;
                this.path.shift();
            } else {
                this.x += (dx/dist)*s;
                this.y += (dy/dist)*s;
            }
        } else {
            this.think();
        }
    }

    think() {
        this.timer--;
        if(this.timer > 0) return;

        if(this.state === 'idle') {
            // å†³ç­–é€»è¾‘
            if(this.stats.health < 40) this.assignTask('hospital', 'healing');
            else if(this.stats.money < (this.personality.lazy?10:60)) this.assignTask(['shop','farm'], 'working');
            else if(this.personality.shopper && this.stats.happy < 70) this.assignTask('shop', 'shopping');
            else {
                // å›å®¶ä¼‘æ¯
                this.assignTask('home', 'idle');
                this.timer = 50; 
            }
        } else {
            // æ‰§è¡Œå®Œä»»åŠ¡åçš„ç»“ç®—
            if(this.state === 'working') { this.stats.money += 20; game.money += 5; this.stats.happy -= 5; }
            if(this.state === 'shopping') { this.stats.money -= 15; this.stats.happy += 30; game.money += 2; }
            if(this.state === 'healing') { this.stats.health = 100; this.stats.money -= 10; }
            this.state = 'idle';
            this.timer = 20;
        }
    }

    assignTask(type, newState) {
        let tx, ty;
        if(type === 'home') {
            tx = this.hx; ty = this.hy;
        } else {
            let targets = game.buildings.filter(b => Array.isArray(type) ? type.includes(b.type) : b.type === type);
            if(targets.length === 0) return;
            let t = targets[Math.floor(Math.random()*targets.length)];
            tx = t.x; ty = t.y;
        }
        let p = findPath(Math.floor(this.x/TILE), Math.floor(this.y/TILE), tx, ty);
        if(p) { this.path = p; this.state = newState; }
    }
}

// --- é€»è¾‘ä¸äº¤äº’ ---
function updateLogic() {
    if(!game.active) return;
    game.tick++;
    game.agents.forEach(a => a.update());
    
    // UI
    document.getElementById('m-val').innerText = "$" + Math.floor(game.money);
    document.getElementById('p-val').innerText = game.agents.length;
    document.getElementById('f-val').innerText = Math.floor(game.food);
    let avgH = game.agents.length ? Math.floor(game.agents.reduce((s,a)=>s+a.stats.happy,0)/game.agents.length) : 100;
    document.getElementById('h-val').innerText = Math.min(100, avgH) + "%";
}

canvas.addEventListener('mousedown', e => {
    if(!game.active) return;
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) / TILE);
    const y = Math.floor((e.clientY - rect.top) / TILE);

    if(game.tool === 'delete') {
        game.buildings = game.buildings.filter(b => !(b.x===x && b.y===y));
        game.grid[y][x] = 0;
        // è‡ªåŠ¨æ¸…é™¤å¤šä½™é“è·¯ä¼šåœ¨ä¸‹ä¸€å¸§ç»˜åˆ¶ä¸­ä½“ç°é€»è¾‘ï¼ˆç®€åŒ–å¤„ç†ï¼‰
    } else {
        if(game.grid[y][x] !== 0) return;
        let cost = 50;
        if(game.money >= cost) {
            game.money -= cost;
            game.grid[y][x] = 1; // æ ‡è®°å»ºç­‘
            game.buildings.push({x, y, type: game.tool});
            
            // æ ¸å¿ƒï¼šæ™ºèƒ½ç”Ÿæˆé“è·¯
            // è¿æ¥åˆ°æœ€è¿‘çš„å·²æœ‰å»ºç­‘
            if(game.buildings.length > 1) {
                let other = game.buildings[game.buildings.length-2];
                let roadPath = findPath(x, y, other.x, other.y);
                if(roadPath) {
                    roadPath.forEach(pt => {
                        if(game.grid[pt.y][pt.x] === 0) game.grid[pt.y][pt.x] = 2; // é“ºè®¾é“è·¯
                    });
                }
            }

            if(game.tool === 'house') {
                for(let i=0; i<3; i++) game.agents.push(new Agent(x, y));
            }
        }
    }
});

canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) / TILE);
    const y = Math.floor((e.clientY - rect.top) / TILE);
    let a = game.agents.find(a => Math.floor(a.x/TILE) === x && Math.floor(a.y/TILE) === y);
    let insp = document.getElementById('inspector');
    if(a) {
        insp.innerHTML = `<b style="color:white">ğŸ‘¤ å±…æ°‘ ID-${Math.floor(a.x)}</b><br>
        æ€§æ ¼: ${a.personality.lazy?'äº«ä¹ä¸»ä¹‰':'å¥‹æ–—é’å¹´'}<br>
        çŠ¶æ€: <span style="color:var(--accent)">${a.state}</span><br>
        èµ„äº§: $${Math.floor(a.stats.money)}`;
    }
});

// --- ç²¾ç¾æ¸²æŸ“ ---
function loop() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    
    // 1. ç»˜åˆ¶èƒŒæ™¯ç½‘æ ¼
    ctx.strokeStyle = '#1e293b';
    ctx.lineWidth = 1;
    for(let i=0; i<=canvas.width; i+=TILE) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,canvas.height); ctx.stroke(); }
    for(let i=0; i<=canvas.height; i+=TILE) { ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(canvas.width,i); ctx.stroke(); }

    // 2. ç»˜åˆ¶é“è·¯
    ctx.fillStyle = '#334155';
    for(let y=0; y<GRID_H; y++) {
        for(let x=0; x<GRID_W; x++) {
            if(game.grid[y][x] === 2) {
                ctx.fillRect(x*TILE+2, y*TILE+2, TILE-4, TILE-4);
            }
        }
    }

    // 3. ç»˜åˆ¶å»ºç­‘ (åŠ é˜´å½±å’Œå‘å…‰)
    game.buildings.forEach(b => {
        ctx.shadowBlur = 15;
        ctx.shadowColor = COLORS[b.type];
        ctx.fillStyle = COLORS[b.type];
        // ç»˜åˆ¶åœ†è§’çŸ©å½¢
        let r = 8;
        let x = b.x*TILE+5, y = b.y*TILE+5, w = TILE-10, h = TILE-10;
        ctx.beginPath();
        ctx.moveTo(x+r, y); ctx.lineTo(x+w-r, y); ctx.quadraticCurveTo(x+w, y, x+w, y+r);
        ctx.lineTo(x+w, y+h-r); ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
        ctx.lineTo(x+r, y+h); ctx.quadraticCurveTo(x, y+h, x, y+h-r);
        ctx.lineTo(x, y+r); ctx.quadraticCurveTo(x, y, x+r, y);
        ctx.fill();
        ctx.shadowBlur = 0;
        
        ctx.fillStyle = 'white';
        ctx.font = "20px Arial";
        ctx.textAlign = "center";
        let icon = "ğŸ ";
        if(b.type==='shop') icon="ğŸ›’";
        if(b.type==='farm') icon="ğŸŒ¾";
        if(b.type==='hospital') icon="ğŸ¥";
        if(b.type==='fire') icon="ğŸš’";
        ctx.fillText(icon, b.x*TILE+20, b.y*TILE+28);
    });

    // 4. ç»˜åˆ¶å°äºº (å¸¦è½¨è¿¹æ„Ÿ)
    game.agents.forEach(a => {
        ctx.fillStyle = a.state === 'working' ? '#f59e0b' : '#f1f5f9';
        ctx.beginPath();
        ctx.arc(a.x, a.y, 5, 0, Math.PI*2);
        ctx.fill();
        // ç»˜åˆ¶ç”Ÿå‘½æ¡
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(a.x-5, a.y-10, (a.stats.health/100)*10, 2);
    });

    requestAnimationFrame(loop);
}

// ç”»å¸ƒè‡ªé€‚åº”
window.addEventListener('resize', () => {
    canvas.width = window.innerWidth - 320;
    canvas.height = window.innerHeight;
});
window.dispatchEvent(new Event('resize'));
</script>
</body>
</html>
