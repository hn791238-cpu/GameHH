<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>末日文字Roguelike：避难所日志</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#111a24;
      --panel2:#0f1720;
      --text:#d7e2ee;
      --muted:#8fa3b8;
      --good:#5ee28b;
      --bad:#ff5f6d;
      --warn:#ffd166;
      --accent:#62a7ff;
      --border: rgba(255,255,255,.08);
      --shadow: 0 10px 30px rgba(0,0,0,.45);
      --radius: 16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      background: radial-gradient(1200px 700px at 30% 10%, rgba(98,167,255,.12), transparent 60%),
                  radial-gradient(900px 600px at 70% 0%, rgba(94,226,139,.10), transparent 55%),
                  var(--bg);
      color: var(--text);
      font-family: var(--sans);
      line-height:1.25;
    }
    header{
      padding:18px 16px 10px;
      max-width: 1100px;
      margin: 0 auto;
    }
    h1{
      margin:0;
      font-size: 18px;
      letter-spacing:.4px;
      color:#e9f2ff;
    }
    .sub{
      margin-top:6px;
      color: var(--muted);
      font-size: 12px;
    }
    .wrap{
      max-width:1100px;
      margin:0 auto;
      padding: 12px 16px 26px;
      display:grid;
      grid-template-columns: 340px 1fr;
      gap: 14px;
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      border-radius: var(--radius);
      overflow:hidden;
    }
    .card .hd{
      padding:12px 14px;
      background: rgba(255,255,255,.03);
      border-bottom: 1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .card .hd .t{
      font-weight:650;
      font-size: 13px;
      color:#e9f2ff;
    }
    .badge{
      font-family: var(--mono);
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 999px;
      border:1px solid var(--border);
      color: var(--muted);
      background: rgba(255,255,255,.02);
      white-space:nowrap;
    }
    .content{ padding: 12px 14px 14px; }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .stat{
      padding: 10px 10px;
      border-radius: 12px;
      border:1px solid var(--border);
      background: rgba(0,0,0,.15);
    }
    .stat.low .v span{ color: var(--warn); }
    .stat.zero .v span{ color: var(--bad); }
    .stat .k{ color: var(--muted); font-size: 11px; }
    .stat .v{
      margin-top:6px;
      font-family: var(--mono);
      font-size: 16px;
      display:flex;
      align-items:baseline;
      gap:8px;
    }
    .delta{
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 999px;
      border:1px solid var(--border);
      color: var(--muted);
    }
    .delta.good{ color: var(--good); border-color: rgba(94,226,139,.25); background: rgba(94,226,139,.08);}
    .delta.bad{ color: var(--bad); border-color: rgba(255,95,109,.25); background: rgba(255,95,109,.08);}
    .delta.warn{ color: var(--warn); border-color: rgba(255,209,102,.25); background: rgba(255,209,102,.08);}

    .list{
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
      margin-top: 10px;
    }
    .pill{
      font-size: 11px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.02);
      color: var(--text);
      padding: 6px 8px;
      border-radius: 999px;
      max-width: 100%;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .pill.muted{ color: var(--muted); }
    .pill.accent{ border-color: rgba(98,167,255,.35); background: rgba(98,167,255,.08); }
    .pill.good{ border-color: rgba(94,226,139,.35); background: rgba(94,226,139,.08); }
    .pill.warn{ border-color: rgba(255,209,102,.35); background: rgba(255,209,102,.08); }
    .pill.bad{ border-color: rgba(255,95,109,.35); background: rgba(255,95,109,.08); }

    .log{
      height: 430px;
      overflow:auto;
      padding: 10px 14px 14px;
      background: rgba(0,0,0,.16);
    }
    .entry{
      padding: 10px 10px;
      border-radius: 12px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.02);
      margin: 10px 0;
    }
    .entry .meta{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      color: var(--muted);
      font-size: 11px;
      font-family: var(--mono);
    }
    .entry .text{ margin-top: 8px; font-size: 13px; color: var(--text); }
    .entry .opts{
      margin-top: 10px;
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
    }
    button{
      border:1px solid var(--border);
      background: rgba(255,255,255,.04);
      color: var(--text);
      padding: 9px 10px;
      border-radius: 12px;
      font-size: 12px;
      cursor:pointer;
      transition: transform .06s ease, background .12s ease, border-color .12s ease;
      user-select:none;
    }
    button:hover{
      background: rgba(255,255,255,.07);
      border-color: rgba(255,255,255,.14);
    }
    button:active{ transform: translateY(1px); }
    button.primary{
      border-color: rgba(98,167,255,.35);
      background: rgba(98,167,255,.10);
    }
    button.danger{
      border-color: rgba(255,95,109,.35);
      background: rgba(255,95,109,.09);
    }
    button.good{
      border-color: rgba(94,226,139,.35);
      background: rgba(94,226,139,.09);
    }
    button:disabled{
      cursor:not-allowed;
      opacity:.55;
      transform:none;
    }

    .row{
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
      align-items:center;
    }
    .small{
      font-size: 11px;
      color: var(--muted);
    }
    .divider{
      height:1px;
      background: var(--border);
      margin: 12px 0;
    }

    .footerbar{
      padding: 10px 14px;
      border-top:1px solid var(--border);
      background: rgba(255,255,255,.02);
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
      justify-content:space-between;
      align-items:center;
    }
    .kbd{
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
      border:1px solid var(--border);
      background: rgba(0,0,0,.18);
      padding: 3px 7px;
      border-radius: 8px;
    }

    .select{
      appearance:none;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid var(--border);
      background: rgba(0,0,0,.22);
      color: var(--text);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
    }
    .select:focus{ outline:2px solid rgba(98,167,255,.35); }

    @media (max-width: 920px){
      .wrap{ grid-template-columns: 1fr; }
      .log{ height: 420px; }
    }
  </style>
</head>
<body>
  <header>
    <h1>避难所日志（文字Roguelike）</h1>
    <div class="sub">随机事件 + 随机奖励 + 资源管理。每回合做关键选择，活下去。</div>
  </header>

  <div class="wrap">
    <!-- LEFT: STATS -->
    <div class="card">
      <div class="hd">
        <div class="t">状态面板</div>
        <div class="badge" id="seedBadge">seed: -</div>
      </div>
      <div class="content">
        <div class="grid2" id="statsGrid"></div>

        <div class="small" id="consumeLine" style="margin-top:10px;"></div>

        <div class="row" style="margin-top:8px; align-items:center; gap:8px;">
          <span class="pill muted">难度</span>
          <select id="difficultySelect" class="select" aria-label="difficulty">
            <option value="easy">简单（剧情）</option>
            <option value="normal" selected>普通（平衡）</option>
            <option value="hard">困难（紧张）</option>
          </select>
          <span class="small" id="difficultyDesc"></span>
        </div>

        <div class="small" id="gearLine" style="margin-top:6px;"></div>

        <div class="divider"></div>

        <div class="row">
          <span class="pill muted">特性</span>
          <span class="small">（每局不同，影响事件与收益）</span>
        </div>
        <div class="list" id="traitsList"></div>

        <div class="divider"></div>

        <div class="row">
          <button class="primary" id="btnNext">下一天：触发随机事件</button>
          <button id="btnRest">休整</button>
          <button id="btnCraft">制造</button>
          <button id="btnUpgrade">科技树</button>
        </div>

        <div class="divider"></div>

        <div class="row">
          <button class="danger" id="btnNewRun">新开一局</button>
          <button id="btnSave">导出存档</button>
          <button id="btnLoad">导入存档</button>
        </div>
        <div class="small" style="margin-top:8px;">
          小提示：<span class="kbd">N</span> 下一天，<span class="kbd">R</span> 休整，<span class="kbd">C</span> 制造，<span class="kbd">U</span> 升级
        </div>
      </div>
    </div>

    <!-- RIGHT: LOG -->
    <div class="card">
      <div class="hd">
        <div class="t">事件日志</div>
        <div class="badge" id="runBadge">Day 1</div>
      </div>
      <div class="log" id="log"></div>
      <div class="footerbar">
        <div class="row">
          <span class="pill accent" id="threatPill">威胁：0</span>
          <span class="pill" id="zombiePill">僵尸进度：-</span>
        </div>
        <div class="row small" id="hintLine">做选择会改变资源与威胁，威胁越高，事件越凶。</div>
      </div>
    </div>
  </div>

<script>
(() => {
  // -----------------------------
  // RNG (seeded)
  // -----------------------------
  function mulberry32(a){
    return function(){
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }
  function hashSeed(str){
    // simple string hash -> uint32
    let h = 2166136261 >>> 0;
    for (let i=0;i<str.length;i++){
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  }

  // -----------------------------
  // Game State
  // -----------------------------
  const DEFAULTS = () => ({
    seedText: randomSeedText(),
    day: 1,
    hp: 20,
    maxHp: 20,
    morale: 10,
    maxMorale: 20,

    energy: 9,
    maxEnergy: 12,

    food: 8,
    water: 8,
    ammo: 6,
    med: 2,
    scrap: 4,

    threat: 0,      // increases difficulty
    zone: 1,        // "distance" / stage
    traits: [],
    inventory: [],  // future extension
    flags: {},

    story: storyDefaults(),

    pendingChoice: null, // if an event is waiting for player choice
    lastDelta: {},

    gear: { weapon: 0, armor: 0 },
    tech: { workshop: 0, armory: 0, purifier: 0 },
    settings: { difficulty: "normal" }
  });

  let state = DEFAULTS();
  let rng = mulberry32(hashSeed(state.seedText));
  const $ = (id) => document.getElementById(id);

  // -----------------------------
  // Difficulty (story-first, adjustable)
  // -----------------------------
  const DIFFICULTY = {
    easy:   { name:"简单", foodCost:2, waterCost:1, hungerDmg:1, thirstDmg:1, lootMult:1.15, combatWeight:0.55, fillerWeight:0.5, craftScale:1.15, fatigue:0, searchMult:1.10 },
    normal: { name:"普通", foodCost:2, waterCost:1, hungerDmg:1, thirstDmg:2, lootMult:1.00, combatWeight:0.85, fillerWeight:0.35, craftScale:1.00, fatigue:1, searchMult:1.00 },
    hard:   { name:"困难", foodCost:3, waterCost:2, hungerDmg:2, thirstDmg:3, lootMult:0.90, combatWeight:1.10, fillerWeight:1.0, craftScale:0.95, fatigue:2, searchMult:0.92 }
  };
  function diff(){
    const key = (state.settings && state.settings.difficulty) || "normal";
    return DIFFICULTY[key] || DIFFICULTY.normal;
  }
  function dailyCosts(){
    return { foodCost: diff().foodCost, waterCost: diff().waterCost };
  }


  // -----------------------------
  // Story System (stateful, linked narrative)
  // -----------------------------
  function storyDefaults(){
    return {
      queue: ["st_intro"],      // upcoming story nodes influenced by choices
      seen: {},                  // nodeId -> true
      vars: {},                  // arbitrary story variables
      last: null                 // last node id
    };
  }

  function storyHas(id){
    return !!state.story.seen[id];
  }

  function storyEnqueue(id){
    if (!id) return;
    if (storyHas(id)) return;
    if (state.story.queue.includes(id)) return;
    state.story.queue.push(id);
  }

  function storyEnqueueMany(ids){
    if (!ids) return;
    for (const id of ids) storyEnqueue(id);
  }

  function setFlag(k, v=true){
    state.flags[k] = v;
  }

  // Convert a story node to logEventCard options with automatic state linkage.
  // This version enforces exactly 4 options per story event:
  //  - up to 3 narrative options from the node
  //  - plus 1 contextual "搜索/停留" option to let you top up resources with risk & buffs.
  function storyOptions(node, ctx){
    const base = (node.options ? node.options(ctx) : []) || [];

    // keep at most 3 authored options (so we always reserve a slot for SEARCH)
    const authored = base.slice(0,3);

    // pad authored options if fewer than 3 (rare)
    while (authored.length < 3){
      authored.push({
        text:"谨慎前进（稳妥）",
        kind:"primary",
        log:"你压低脚步，小心绕过风险点。",
        delta:{ morale:+0, threat:+0, energy:-1 },
        next:[]
      });
    }

    // contextual search option (resource side-quest at the current story location)
    const searchOpt = {
      text:"搜索周围（停留更久，找物资）",
      kind:"primary",
      req: ()=> state.energy >= 2,
      resolve: ()=>{
        // risk/reward tuned for story-first experience
        const mult = diff().searchMult || 1.0;
        const roll = r();

        // base loot points
        let pts = Math.floor((4 + ri(4)) * ctx.lootMult * mult);
        // focused buff increases search quality
        if (state.flags.focusedTurns) pts = Math.floor(pts * (1 + 0.08*state.flags.focusedTurns));

        // decide outcome tier
        let log = "你在现场多停留了一会儿，仔细搜索角落。";
        let delta = { energy:-2, threat:+0, morale:+0 };

        if (roll < 0.55){
          // good find
          const gain = splitLoot(Math.max(2, pts));
          delta = { ...delta, ...gain, morale:+1 };
          // 20% chance to gain a short buff
          if (r() < 0.20){
            state.flags.focusedTurns = Math.max(state.flags.focusedTurns||0, 2);
            log += ` 你找到了有用的物资：${formatGain(gain)}。你变得更警觉（接下来几天搜索更容易）。`;
          } else {
            log += ` 你找到了有用的物资：${formatGain(gain)}。`;
          }
        } else if (roll < 0.85){
          // neutral: small gain, some fatigue
          const gain = splitLoot(Math.max(1, Math.floor(pts*0.65)));
          delta = { ...delta, ...gain, energy:-3 };
          log += ` 你只翻到一些零碎：${formatGain(gain)}，但也更累了。`;
        } else {
          // bad: ambush / trouble
          const gain = splitLoot(Math.max(1, Math.floor(pts*0.5)));
          const dmg = Math.ceil((3 + state.zone) * (0.7 + r()*0.6) * ctx.ambushDmgMult);
          state.flags.exhaustedTurns = Math.max(state.flags.exhaustedTurns||0, 2);
          delta = { ...delta, ...gain, hp:-dmg, morale:-1, threat:+1, energy:-4 };
          log += ` 你翻找时惊动了什么东西（-${dmg} 生命）。你狼狈离开，但仍带走：${formatGain(gain)}。`;
        }

        // mark and link (search counts as experiencing this node)
        state.story.seen[node.id] = true;
        state.story.last = node.id;

        // search doesn't change story queue, it just consumes the day at this location
        endTurn({ log, delta });
      }
    };

    const all = [...authored, searchOpt].map(opt => ({
      text: opt.text,
      kind: opt.kind || "primary",
      req: opt.req || (()=>true),
      resolve: ()=>{
        // apply flag/var effects
        if (opt.setFlags){
          for (const [k,v] of Object.entries(opt.setFlags)) setFlag(k, v);
        }
        if (opt.setVars){
          for (const [k,v] of Object.entries(opt.setVars)) state.story.vars[k]=v;
        }

        // if opt has its own resolve, use it
        if (typeof opt.resolve === 'function'){
          opt.resolve(ctx);
          return;
        }

        // mark and link
        state.story.seen[node.id] = true;
        state.story.last = node.id;

        // otherwise do default endTurn with delta and enqueue next
        storyEnqueueMany(opt.next);
        endTurn({
          log: opt.log || `你的选择让事情向前推进。`,
          delta: opt.delta || { morale:+0, threat:+0, energy:-1 }
        });
      }
    }));

    return ensureFour(all);
  }

  // Story nodes: random *within* a continuous, choice-driven graph.
  // Rules:
  // - Nodes become eligible if their requirements are met.
  // - Player choices enqueue follow-ups, so the next days reflect what you did.
  const STORY_NODES = [
    {
      id:"st_intro",
      dayMin: 1,
      title:"一张被雨淋湿的地图",
      intro:"你在避难所门口的垃圾堆里翻到一张被雨水泡皱的城市地图，角落写着：‘不要相信晚上会亮灯的楼。’",
      requires:()=> true,
      options:(ctx)=>[
        {
          text:"把地图收好（+士气，解锁线索）",
          kind:"good",
          log:"你把地图折好塞进内袋。也许它能救你一命。",
          delta:{ morale:+1, threat:+0 },
          setVars:{ clue:"map" },
          next:["radio_1","diary_1"]
        },
        {
          text:"用来加固窗缝（+防御感，解锁‘稳健’路线）",
          kind:"primary",
          log:"你用地图把窗缝堵了堵，至少今晚风不会那么冷。",
          delta:{ morale:+1, threat:+0 },
          setVars:{ clue:"fortify" },
          next:["diary_1","water_line_1"]
        },
        {
          text:"丢掉它（更快行动）",
          kind:"bad",
          log:"你不想被旧纸牵着走，直接把它丢进积水里。",
          delta:{ morale:+0, threat:+0 },
          next:["radio_1"]
        }
      ]
    },

    {
      id:"radio_1",
      dayMin: 2,
      title:"广播电台残响",
      intro:"你在一间办公室里发现一台半坏的短波电台，喇叭里断断续续传来有人在喊坐标。",
      requires:()=> !storyHas("radio_1"),
      options:(ctx)=>[
        {
          text:"调频收听（+士气，写下坐标）",
          kind:"good",
          log:"你记下了断续的坐标与一句暗号：‘海鸥不在夜里飞。’",
          delta:{ morale:+2, threat:+0 },
          setFlags:{ radioClue:true },
          next:["radio_2","blackflag_1"]
        },
        {
          text:"拆下零件（+废料，动静更大）",
          kind:"primary",
          log:"你把电台拆成可用的零件。金属撞击声在楼道里回荡。",
          delta:{ scrap:+3, morale:+0, threat:+1 },
          next:["blackflag_1"]
        },
        {
          text:"离开（不暴露位置）",
          kind:"muted",
          log:"你决定不浪费时间，先活过今天再说。",
          delta:{ morale:+0, threat:+0 },
          next:["diary_1"]
        }
      ]
    },

    {
      id:"radio_2",
      dayMin: 3,
      title:"坐标的第二半句",
      intro:"你反复回想那串坐标，突然意识到少了一段。也许有人知道补全方法。",
      requires:()=> state.flags.radioClue && !storyHas("radio_2"),
      options:(ctx)=>[
        {
          text:"去找‘懂无线电的人’（更冒险，但推进剧情）",
          kind:"primary",
          log:"你决定去碰一碰运气：找到懂行的人，补全坐标。",
          delta:{ morale:+0, threat:+1 },
          setVars:{ pursuit:"radio" },
          next:["survivor_signal_1","subway_1"]
        },
        {
          text:"先把坐标刻在墙上（留后路）",
          kind:"good",
          log:"你把坐标刻在避难所内墙上。就算丢了纸，也不会丢了路。",
          delta:{ morale:+1, threat:+0 },
          setVars:{ pursuit:"stay" },
          next:["water_line_1","kid_arrow_1"]
        }
      ]
    },

    {
      id:"diary_1",
      dayMin: 2,
      title:"日记残页",
      intro:"一沓发黄的纸夹在抽屉里，像是某人的日记。字迹潦草，但能读出恐惧与坚持。",
      requires:()=> !storyHas("diary_1"),
      options:(ctx)=>[
        {
          text:"认真读完（+士气，得到警告）",
          kind:"good",
          log:"你记下最重要的一句：‘不要在夜里走那条桥。’",
          delta:{ morale:+2, threat:+0 },
          setFlags:{ diaryClue:true },
          next:["bridge_1","kid_arrow_1"]
        },
        {
          text:"收好带走（以后或许能换信任）",
          kind:"primary",
          log:"你把日记塞进包里。也许它能证明你不是骗子。",
          delta:{ morale:+1, threat:+0 },
          setFlags:{ diaryKept:true },
          next:["survivor_signal_1","blackflag_1"]
        },
        {
          text:"当引火物（立刻收益）",
          kind:"muted",
          log:"你撕了几张纸当引火物，至少能热一顿。",
          delta:{ food:+1, morale:+0, threat:+0 },
          next:["water_line_1"]
        }
      ]
    },

    {
      id:"bridge_1",
      dayMin: 4,
      title:"那座桥",
      intro:"你绕到地图上提到的那座桥。白天看起来很普通，但桥下的回声让你不舒服。",
      requires:()=> state.flags.diaryClue && !storyHas("bridge_1"),
      options:(ctx)=>[
        {
          text:"白天快速通过（稳）",
          kind:"good",
          log:"你压低脚步快速通过。桥下的影子没追上来。",
          delta:{ morale:+1, threat:+0 },
          next:["survivor_signal_1","safehouse_1"]
        },
        {
          text:"下桥查看（可能高收益也可能出事）",
          kind:"primary",
          resolve:(ctx)=>{
            const bad = r() < (0.22 + state.threat*0.02 - (state.flags.lucky?0.06:0));
            if (!bad){
              storyEnqueueMany(["safehouse_1"]);
              endTurn({log:"桥下藏着一个旧背包。你拿走了补给。", delta:{food:+3, water:+2, ammo:+2, morale:+1, threat:+0}});
            } else {
              storyEnqueueMany(["blackflag_1"]);
              const dmg = Math.ceil((3+state.zone)*(0.7+r()*0.8)*ctx.ambushDmgMult);
              endTurn({log:`桥下的声响引来游荡者，你狼狈逃离（-${dmg} 生命）。`, delta:{hp:-dmg, morale:-1, threat:+2}});
            }
          }
        }
      ]
    },

    {
      id:"water_line_1",
      dayMin: 3,
      title:"临时净水点",
      intro:"你看到一处被塑料布遮住的水桶，旁边有粗糙的过滤装置。看起来有人在这里取水。",
      requires:()=> !storyHas("water_line_1"),
      options:(ctx)=>[
        {
          text:"补满水袋（+水，但可能引人注意）",
          kind:"primary",
          log:"你装了些水离开。",
          delta:{ water:+4, morale:+0, threat:+1 },
          next:["blackflag_1"]
        },
        {
          text:"先过滤再装（耗废料，降低风险）",
          kind:"good",
          req:()=> state.scrap>=1,
          log:"你用一点零件加固过滤装置，取水更安心。",
          delta:{ scrap:-1, water:+5, morale:+1, threat:+0 },
          next:["safehouse_1"]
        },
        {
          text:"不碰它",
          kind:"muted",
          log:"你不确定这里是否安全，选择离开。",
          delta:{ morale:+0, threat:+0 },
          next:["kid_arrow_1"]
        }
      ]
    },

    {
      id:"survivor_signal_1",
      dayMin: 4,
      title:"求救信号",
      intro:"远处楼里闪了两下灯。有人用镜面反光引你注意。",
      requires:()=> !storyHas("survivor_signal_1"),
      options:(ctx)=>[
        {
          text:"回应并靠近（可能结识同伴）",
          kind:"good",
          resolve:(ctx)=>{
            const bad = r() < (0.25 + state.threat*0.02 - (state.flags.lucky?0.06:0));
            if (!bad){
              setFlag('survivorMet', true);
              storyEnqueueMany(["safehouse_1","radio_helper_1"]);
              endTurn({log:"你遇到一位幸存者，对方给了你一点物资作为谢意，并说‘北边有个安全点’。", delta:{food:+2, water:+1, morale:+2, threat:+0}});
            }else{
              storyEnqueueMany(["blackflag_1"]);
              endTurn({log:"你靠近后发现是诱饵。你仓促撤离，心情糟透了。", delta:{morale:-2, threat:+2}});
            }
          }
        },
        {
          text:"保持距离观察（小收益）",
          kind:"primary",
          log:"你确认附近没人跟踪，顺手搜到点零件。",
          delta:{ scrap:+1, morale:+1, threat:+0 },
          next:["kid_arrow_1"]
        },
        {
          text:"无视",
          kind:"muted",
          log:"你不想冒险。",
          delta:{ morale:+0, threat:+0 },
          next:["blackflag_1"]
        }
      ]
    },

    {
      id:"radio_helper_1",
      dayMin: 5,
      title:"懂无线电的人",
      intro:"那位幸存者说，他认识一个会修无线电的人，但那人躲在地铁附近。",
      requires:()=> state.flags.survivorMet && state.flags.radioClue && !storyHas("radio_helper_1"),
      options:(ctx)=>[
        {
          text:"去地铁找他（推进坐标线）",
          kind:"primary",
          log:"你决定赌一把：坐标可能意味着真正的出路。",
          delta:{ morale:+0, threat:+1 },
          next:["subway_1"]
        },
        {
          text:"暂缓（先稳住补给）",
          kind:"good",
          log:"你决定先把状态拉稳，再去碰那条线。",
          delta:{ morale:+1, threat:+0 },
          next:["kid_arrow_1","blackflag_1"]
        }
      ]
    },

    {
      id:"subway_1",
      dayMin: 5,
      title:"封闭的地铁闸门",
      intro:"地铁口被铁闸封死，里面黑得像墨。你听见里面有水滴声，也许有物资，也许有麻烦。",
      requires:()=> !storyHas("subway_1"),
      options:(ctx)=>[
        {
          text:"用工具撬开（耗废料，收益更高）",
          kind:"primary",
          req:()=> state.scrap>=2,
          resolve:(ctx)=>{
            const bad = r() < (0.18 + state.threat*0.02 - (state.flags.lucky?0.05:0));
            if(!bad){
              setFlag('subwayOpened', true);
              storyEnqueueMany(["safehouse_1","blackflag_1"]);
              endTurn({log:"你撬开闸门，从站台角落带走了补给。", delta:{scrap:-2, food:+3, water:+3, ammo:+2, morale:+1, threat:+1}});
            }else{
              storyEnqueueMany(["blackflag_1"]);
              endTurn({log:"闸门一响就惊动了东西，你只能撤退。", delta:{scrap:-2, morale:-1, threat:+2}});
            }
          }
        },
        {
          text:"丢石子探路（低成本）",
          kind:"good",
          log:"回声很空。你捡了点散落的零件就走。",
          delta:{ scrap:+1, morale:+0, threat:+0 },
          next:["kid_arrow_1"]
        },
        {
          text:"离开",
          kind:"muted",
          log:"你不想进这种地方。",
          delta:{ morale:+0, threat:+0 },
          next:["blackflag_1"]
        }
      ]
    },

    {
      id:"kid_arrow_1",
      dayMin: 4,
      title:"小孩的涂鸦箭头",
      intro:"墙上有新鲜的涂鸦箭头，像是在指向某处：‘这里有吃的’。",
      requires:()=> !storyHas("kid_arrow_1"),
      options:(ctx)=>[
        {
          text:"跟着箭头走（可能有补给，也可能是陷阱）",
          kind:"primary",
          resolve:(ctx)=>{
            const bad = r() < (0.22 + state.threat*0.02 - (state.flags.lucky?0.06:0));
            if(!bad){
              setFlag('trustedSigns', true);
              storyEnqueueMany(["safehouse_1"]);
              endTurn({log:"你找到一处隐藏的储物箱。", delta:{food:+4, water:+2, morale:+2, threat:+0}});
            }else{
              storyEnqueueMany(["blackflag_1"]);
              const dmg = Math.ceil((3+state.zone)*(0.7+r()*0.8)*ctx.ambushDmgMult);
              endTurn({log:`你踩到碎玻璃引来动静，被迫冲出去（-${dmg} 生命）。`, delta:{hp:-dmg, morale:-1, threat:+2}});
            }
          }
        },
        {
          text:"只在附近搜一下（稳）",
          kind:"good",
          log:"你在附近捡到些可用的小东西。",
          delta:{ scrap:+2, morale:+1, threat:+0 },
          next:["safehouse_1"]
        },
        {
          text:"不信这种话",
          kind:"muted",
          log:"你不想被牵着鼻子走。",
          delta:{ morale:+0, threat:+0 },
          next:["blackflag_1"]
        }
      ]
    },

    {
      id:"blackflag_1",
      dayMin: 5,
      title:"黑旗帮哨",
      intro:"一名持械的哨兵挡住去路，臂章上画着黑色旗帜。‘过路费。’",
      requires:()=> !storyHas("blackflag_1"),
      options:(ctx)=>[
        {
          text:"交废料（2废料换平安）",
          kind:"primary",
          req:()=> state.scrap>=2,
          log:"你把废料递过去，对方放你离开。",
          delta:{ scrap:-2, morale:+0, threat:+0 },
          setFlags:{ blackflagPaid:true },
          next:["safehouse_1"]
        },
        {
          text:"尝试谈判（需要士气）",
          kind:"good",
          req:()=> state.morale>=8,
          log:"你稳住语气讲明处境，对方嘟囔两句，还是放你过去。",
          delta:{ morale:+1, threat:+0 },
          setFlags:{ blackflagTalked:true },
          next:["safehouse_1"]
        },
        {
          text:"鸣枪逼退（消耗弹药，惹麻烦）",
          kind:"bad",
          req:()=> state.ammo>=2,
          log:"你朝天鸣枪，对方退后让路，但动静引来关注。",
          delta:{ ammo:-2, morale:+0, threat:+2 },
          setFlags:{ blackflagHostile:true },
          next:["finale_1"]
        },
        {
          text:"撤退绕路（耗神）",
          kind:"muted",
          log:"你绕了一大圈，安全但很累。",
          delta:{ morale:-1, threat:+0 },
          next:["safehouse_1"]
        }
      ]
    },

    {
      id:"safehouse_1",
      dayMin: 7,
      title:"北边的安全点",
      intro:"你再次想起那句‘北边有个安全点’。如果它是真的，也许你能换到长期生存的机会。",
      requires:()=> !storyHas("safehouse_1") && (state.flags.survivorMet || state.flags.radioClue || state.flags.trustedSigns),
      options:(ctx)=>[
        {
          text:"动身去找（推进主线）",
          kind:"primary",
          log:"你决定把命押在‘安全点’上。",
          delta:{ morale:+1, threat:+1 },
          setFlags:{ seekingSafehouse:true },
          next:["safehouse_2","finale_1"]
        },
        {
          text:"先观察周边（更稳）",
          kind:"good",
          log:"你决定先摸清周边，再做决定。",
          delta:{ morale:+1, threat:+0 },
          next:["safehouse_2"]
        },
        {
          text:"不去（坚守自己的避难所）",
          kind:"muted",
          log:"你不相信任何‘安全点’，决定把命押在自己的屋檐下。",
          delta:{ morale:+0, threat:+0 },
          setFlags:{ stayShelter:true },
          next:["finale_1"]
        }
      ]
    },

    {
      id:"safehouse_2",
      dayMin: 9,
      title:"铁门后的声音",
      intro:"夜里，你在北边一处铁门前听见低声交谈。有人真的在这里活着。门后的人问：‘暗号？’",
      requires:()=> (!!state.flags.seekingSafehouse) && !storyHas("safehouse_2"),
      options:(ctx)=>[
        {
          text:"说出暗号（需要你听过广播）",
          kind:"good",
          req:()=> state.flags.radioClue,
          log:"门后的沉默持续了几秒，然后铁门缓缓打开了一条缝。",
          delta:{ morale:+2, threat:+0 },
          setFlags:{ safehouseEntered:true },
          next:["finale_1"]
        },
        {
          text:"递上日记残页（证明你不是随便的人）",
          kind:"primary",
          req:()=> !!state.flags.diaryKept,
          log:"门后的人翻了翻纸页，语气软了些：‘进来。’",
          delta:{ morale:+2, threat:+0 },
          setFlags:{ safehouseEntered:true },
          next:["finale_1"]
        },
        {
          text:"强行闯入（高风险）",
          kind:"bad",
          resolve:(ctx)=>{
            const bad = r() < (0.35 + state.threat*0.02 - (state.flags.lucky?0.06:0));
            if (!bad){
              setFlag('safehouseEntered', true);
              endTurn({log:"你趁门缝打开的瞬间挤了进去，里面的人被迫让你留下。", delta:{morale:-1, threat:+2}});
              storyEnqueueMany(["finale_1"]);
            } else {
              const dmg = Math.ceil((4+state.zone)*(0.9+r()*0.9)*ctx.ambushDmgMult);
              endTurn({log:`你被推倒在门外，混乱中挨了一下（-${dmg} 生命）。`, delta:{hp:-dmg, morale:-2, threat:+2}});
              storyEnqueueMany(["finale_1"]);
            }
          }
        }
      ]
    },

    {
      id:"finale_1",
      dayMin: 12,
      title:"你要活成什么样",
      intro:"你突然意识到：你不是在‘等灾难结束’，你是在选择自己未来的形状。",
      requires:()=> !storyHas("finale_1") && state.day >= 12,
      options:(ctx)=>[
        {
          text:"迁移：追随线索去更远的地方（结局分支：远行）",
          kind:"primary",
          log:"你决定不再只守着这间屋子。你把必需品打包，准备离开。",
          delta:{ morale:+2, threat:+1 },
          setFlags:{ ending:"wander" },
          next:[]
        },
        {
          text:"结盟：加入铁门后的群体（结局分支：据点）",
          kind:"good",
          req:()=> !!state.flags.safehouseEntered,
          log:"你选择相信‘人群’，也许这就是文明剩下的部分。",
          delta:{ morale:+3, threat:+0 },
          setFlags:{ ending:"settle" },
          next:[]
        },
        {
          text:"坚守：加固避难所，做自己的城（结局分支：坚守）",
          kind:"muted",
          log:"你决定继续守住这里，把它变成真正的堡垒。",
          delta:{ morale:+1, threat:+0 },
          setFlags:{ ending:"hold" },
          next:[]
        }
      ]
    }
  ];

  function storyPickNode(){
    // Chance to serve a story node today.
    // Make it frequent early, and still common later.
    const baseChance = 0.78;
    const bump = state.story.queue.length ? 0.15 : 0;
    const chance = clamp(baseChance + bump - Math.max(0, (state.threat-10))*0.02, 0.55, 0.92);
    if (r() > chance) return null;

    const ctx = ctxBase();

    // Candidate set: queued nodes first, otherwise any eligible unseen nodes.
    const queued = state.story.queue
      .map(id => STORY_NODES.find(n=>n.id===id))
      .filter(n=>n && !storyHas(n.id) && (n.dayMin||1) <= state.day && (!n.requires || n.requires(ctx)));

    let candidates = queued;
    if (!candidates.length){
      candidates = STORY_NODES.filter(n=>!storyHas(n.id) && (n.dayMin||1) <= state.day && (!n.requires || n.requires(ctx)));
    }
    if (!candidates.length) return null;

    // Weight: prefer queued nodes, and prefer nodes that reference recent flags
    const weights = candidates.map(n=>{
      let w = 1;
      if (state.story.queue.includes(n.id)) w += 2.2;
      if (n.id.startsWith('finale')) w += 0.8;
      if (n.id.includes('safehouse') && state.flags.seekingSafehouse) w += 1.2;
      if (n.id.includes('radio') && state.flags.radioClue) w += 0.8;
      return w;
    });

    const node = weightedPick(candidates, weights);

    // If it came from queue, remove it from queue now (so it doesn't repeat)
    state.story.queue = state.story.queue.filter(id=>id!==node.id);

    return node;
  }

  // -----------------------------
  // Content Pools
  // -----------------------------
  const TRAITS = [
    {
      id:"scavenger",
      name:"拾荒者",
      desc:"搜刮更容易出货（+10% 资源收益）",
      mod:(ctx)=>{ ctx.lootMult *= 1.10; }
    },
    {
      id:"medic",
      name:"急救员",
      desc:"医疗效率更高（医疗/休整回血 +1）",
      mod:(ctx)=>{ ctx.restHeal += 1; ctx.medHeal += 1; }
    },
    {
      id:"sharpshooter",
      name:"神枪手",
      desc:"战斗更省弹（战斗弹药消耗 -1 最低0）",
      mod:(ctx)=>{ ctx.combatAmmoDiscount += 1; }
    },
    {
      id:"paranoid",
      name:"多疑",
      desc:"更难被偷袭（陷阱/伏击伤害 -20%）",
      mod:(ctx)=>{ ctx.ambushDmgMult *= 0.8; }
    },
    {
      id:"tinkerer",
      name:"修理匠",
      desc:"制造更划算（制造消耗废料 -1 最低0）",
      mod:(ctx)=>{ ctx.craftScrapDiscount += 1; }
    },
    {
      id:"runner",
      name:"跑得快",
      desc:"逃跑更容易（逃跑成功率 +20%）",
      mod:(ctx)=>{ ctx.escapeBonus += 0.20; }
    },
  ];

  function randomSeedText(){
    const a = ["WASTELAND","SHELTER","DUST","NIGHT","HUNGER","STATIC","ECHO","RUST"];
    const b = Math.floor(Math.random()*9999).toString().padStart(4,"0");
    return a[Math.floor(Math.random()*a.length)] + "-" + b;
  }

  const EVENT_TEMPLATES = [
    {
      type:"scavenge",
      title:"废墟超市",
      intro:"你发现一间被洗劫过的超市，货架下还有些东西。",
      options:(ctx)=>[
        {
          text:"谨慎搜刮（低风险）",
          resolve:()=> scavenge(ctx, {risk:"low"})
        },
        {
          text:"深入后仓（高收益/高风险）",
          resolve:()=> scavenge(ctx, {risk:"high"})
        },
        {
          text:"放弃，继续前进",
          resolve:()=> endTurn({log:"你决定不冒险。", delta:{morale:+0}})
        }
      ]
    },
    {
      type:"combat",
      title:"街角尸群",
      intro:"远处传来拖行声，一小群感染者挡住了路线。",
      options:(ctx)=>[
        {
          text:`开火清路（耗弹）`,
          resolve:()=> combat(ctx, {style:"shoot"})
        },
        {
          text:`绕路潜行（耗时间/概率失败）`,
          resolve:()=> combat(ctx, {style:"sneak"})
        },
        {
          text:`硬跑（高概率受伤）`,
          resolve:()=> combat(ctx, {style:"run"})
        }
      ]
    },
    {
      type:"trade",
      title:"流浪商人",
      intro:"一个戴防毒面具的人从阴影里出现：'换点东西？'",
      options:(ctx)=>[
        {
          text:"用废料换食物（2废料→3食物）",
          req:()=> state.scrap >= 2,
          resolve:()=> trade({scrap:-2, food:+3}, "你用废料换到了罐头。")
        },
        {
          text:"用弹药换医疗（3弹→1医疗）",
          req:()=> state.ammo >= 3,
          resolve:()=> trade({ammo:-3, med:+1}, "他递来一支止血针。")
        },
        {
          text:"打劫他（高风险高回报）",
          resolve:()=> mug(ctx)
        }
      ]
    },
    {
      type:"weather",
      title:"酸雨",
      intro:"天空发绿，酸雨落下。暴露在外会灼伤皮肤。",
      options:(ctx)=>[
        {
          text:"就地找掩体（消耗水/士气）",
          resolve:()=> weather(ctx, {choice:"shelter"})
        },
        {
          text:"硬顶着赶路（受伤/加威胁）",
          resolve:()=> weather(ctx, {choice:"push"})
        }
      ]
    },
    {
      type:"trap",
      title:"地雷区",
      intro:"你看到地面有不自然的凸起——有人布了雷。",
      options:(ctx)=>[
        {
          text:"慢慢排雷（耗时但安全）",
          resolve:()=> trap(ctx, {choice:"disarm"})
        },
        {
          text:"赌一把冲过去（概率受伤）",
          resolve:()=> trap(ctx, {choice:"dash"})
        }
      ]
    },
    {
      type:"story",
      title:"广播电台残响",
      intro:"你在一间办公室里发现一台半坏的短波电台，喇叭里断断续续传来有人在喊坐标。",
      options:(ctx)=>[
        {
          text:"调频收听（+士气，解锁线索）",
          resolve:()=>{
            state.flags.radioClue = true;
            endTurn({log:"你记下了断续的坐标与一句暗号。也许以后用得上。", delta:{morale:+2, threat:+0}});
          }
        },
        {
          text:"拆下零件（+废料，略吵）",
          resolve:()=> endTurn({log:"你把电台拆成可用的零件。", delta:{scrap:+3, morale:+0, threat:+1}})
        },
        {
          text:"离开",
          resolve:()=> endTurn({log:"你决定不浪费时间。", delta:{morale:+0, threat:+0}})
        }
      ]
    },
    {
      type:"story",
      title:"日记残页",
      intro:"一沓发黄的纸夹在抽屉里，像是某人的日记。字迹潦草，但能读出恐惧与坚持。",
      options:(ctx)=>[
        {
          text:"认真读完（+士气，获得线索）",
          resolve:()=>{
            state.flags.diaryRead = (state.flags.diaryRead||0) + 1;
            const bonus = state.flags.diaryRead>=3 ? 3 : 2;
            endTurn({log:"你把关键内容记在心里：‘不要在夜里走那条桥。’", delta:{morale:+bonus, threat:+0}});
          }
        },
        {
          text:"撕下空白页当引火物（+食物/补给小收益）",
          resolve:()=> endTurn({log:"你留了几张纸做引火物，至少能热一顿。", delta:{food:+1, morale:+0, threat:+0}})
        },
        {
          text:"收好带走（以后或许有用）",
          resolve:()=>{ state.flags.diaryKept = true; endTurn({log:"你把日记塞进包里。", delta:{morale:+1, threat:+0}}); }
        }
      ]
    },
    {
      type:"water",
      title:"临时净水点",
      intro:"你看到一处被塑料布遮住的水桶，旁边有粗糙的过滤装置。看起来有人在这里取水。",
      options:(ctx)=>[
        {
          text:"补满水袋（+水，但可能引人注意）",
          resolve:()=> endTurn({log:"你装了些水离开。", delta:{water:+4, morale:+0, threat:+1}})
        },
        {
          text:"先过滤再装（耗废料，降低风险）",
          req:()=> state.scrap>=1,
          resolve:()=> endTurn({log:"你用一点零件加固过滤装置，取水更安心。", delta:{scrap:-1, water:+5, morale:+1, threat:+0}})
        },
        {
          text:"不碰它",
          resolve:()=> endTurn({log:"你不确定这里是否安全，选择离开。", delta:{morale:+0, threat:+0}})
        }
      ]
    },
    {
      type:"story",
      title:"求救信号",
      intro:"远处楼里闪了两下灯。有人用镜面反光引你注意。",
      options:(ctx)=>[
        {
          text:"回应并靠近（可能结识同伴）",
          resolve:()=>{
            const bad = r() < (0.25 + state.threat*0.02 - (state.flags.lucky?0.06:0));
            if(!bad){
              state.flags.survivorMet = true;
              endTurn({log:"你遇到一位幸存者，对方给了你一点物资作为谢意，并说‘北边有个安全点’。", delta:{food:+2, water:+1, morale:+2, threat:+0}});
            }else{
              endTurn({log:"你靠近后发现是诱饵。你仓促撤离，心情糟透了。", delta:{morale:-2, threat:+2}});
            }
          }
        },
        {
          text:"保持距离观察（小收益）",
          resolve:()=> endTurn({log:"你确认附近没人跟踪，顺手搜到点零件。", delta:{scrap:+1, morale:+1, threat:+0}})
        },
        {
          text:"无视",
          resolve:()=> endTurn({log:"你不想冒险。", delta:{morale:+0, threat:+0}})
        }
      ]
    },
    {
      type:"story",
      title:"黑旗帮哨",
      intro:"一名持械的哨兵挡住去路，臂章上画着黑色旗帜。‘过路费。’",
      options:(ctx)=>[
        {
          text:"交废料（2废料换平安）",
          req:()=> state.scrap>=2,
          resolve:()=> endTurn({log:"你把废料递过去，对方放你离开。", delta:{scrap:-2, morale:+0, threat:+0}})
        },
        {
          text:"用弹药吓退（消耗弹药，威胁上升）",
          req:()=> state.ammo>=2,
          resolve:()=> endTurn({log:"你朝天鸣枪，对方退后让路，但动静引来关注。", delta:{ammo:-2, morale:+0, threat:+2}})
        },
        {
          text:"尝试谈判（看士气）",
          req:()=> state.morale>=8,
          resolve:()=> endTurn({log:"你稳住语气讲明处境，对方嘟囔两句，还是放你过去。", delta:{morale:+1, threat:+0}})
        },
        {
          text:"撤退绕路（耗神）",
          resolve:()=> endTurn({log:"你绕了一大圈，安全但很累。", delta:{morale:-1, threat:+0}})
        }
      ]
    },
    {
      type:"story",
      title:"小孩的涂鸦箭头",
      intro:"墙上有新鲜的涂鸦箭头，像是在指向某处：‘这里有吃的’。",
      options:(ctx)=>[
        {
          text:"跟着箭头走（可能有补给，也可能是陷阱）",
          resolve:()=>{
            const bad = r() < (0.22 + state.threat*0.02 - (state.flags.lucky?0.06:0));
            if(!bad){
              endTurn({log:"你找到一处隐藏的储物箱。", delta:{food:+4, water:+2, morale:+2, threat:+0}});
            }else{
              const dmg = Math.ceil((3+state.zone)*(0.7+r()*0.8)*ctx.ambushDmgMult);
              endTurn({log:`你踩到碎玻璃引来动静，被迫冲出去（-${dmg} 生命）。`, delta:{hp:-dmg, morale:-1, threat:+2}});
            }
          }
        },
        {
          text:"只在附近搜一下（稳）",
          resolve:()=> endTurn({log:"你在附近捡到些可用的小东西。", delta:{scrap:+2, morale:+1, threat:+0}})
        },
        {
          text:"不信这种话",
          resolve:()=> endTurn({log:"你不想被牵着鼻子走。", delta:{morale:+0, threat:+0}})
        }
      ]
    },
    {
      type:"story",
      title:"封闭的地铁闸门",
      intro:"地铁口被铁闸封死，里面黑得像墨。你听见里面有水滴声，也许有物资，也许有麻烦。",
      options:(ctx)=>[
        {
          text:"用工具撬开（耗废料，收益更高）",
          req:()=> state.scrap>=2,
          resolve:()=>{
            const bad = r() < (0.18 + state.threat*0.02 - (state.flags.lucky?0.05:0));
            if(!bad){
              endTurn({log:"你撬开闸门，从站台角落带走了补给。", delta:{scrap:-2, food:+3, water:+3, ammo:+2, morale:+1, threat:+1}});
            }else{
              endTurn({log:"闸门一响就惊动了东西，你只能撤退。", delta:{scrap:-2, morale:-1, threat:+2}});
            }
          }
        },
        {
          text:"丢石子探路（低成本）",
          resolve:()=> endTurn({log:"回声很空。你捡了点散落的零件就走。", delta:{scrap:+1, morale:+0, threat:+0}})
        },
        {
          text:"离开",
          resolve:()=> endTurn({log:"你不想进这种地方。", delta:{morale:+0, threat:+0}})
        }
      ]
    }
  ];

  const UPGRADE_POOL = [
    {
      id:"maxhp",
      name:"+3 最大生命",
      desc:"更抗揍。",
      apply:()=> { state.maxHp += 3; state.hp += 3; }
    },
    {
      id:"maxmorale",
      name:"+4 最大士气",
      desc:"更稳。",
      apply:()=> { state.maxMorale += 4; state.morale += 2; }
    },
    {
      id:"findWater",
      name:"净水技巧",
      desc:"每天消耗水 -1（最低1）。",
      apply:()=> { state.flags.waterSaver = true; }
    },
    {
      id:"ammoSmith",
      name:"简易压弹",
      desc:"制造：1废料→+2弹药。",
      apply:()=> { state.flags.ammoCraft = true; }
    },
    {
      id:"quietSteps",
      name:"无声脚步",
      desc:"潜行成功率 +15%。",
      apply:()=> { state.flags.sneakBonus = (state.flags.sneakBonus||0) + 0.15; }
    },
    {
      id:"lucky",
      name:"好运",
      desc:"所有随机奖励小幅偏向正面。",
      apply:()=> { state.flags.lucky = true; }
    }
  ];

  // -----------------------------
  // Utility
  // -----------------------------
  function r(){
    return rng();
  }
  function ri(n){
    return Math.floor(r()*n);
  }
  function pick(arr){
    return arr[ri(arr.length)];
  }
  function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }

  function ctxBase(){
    const ctx = {
      lootMult: 1,
      restHeal: 2,
      medHeal: 5,
      ambushDmgMult: 1,
      combatAmmoDiscount: 0,
      craftScrapDiscount: 0,
      escapeBonus: 0,
      sneakBonus: (state.flags.sneakBonus||0),
      lucky: !!state.flags.lucky
    };
    // apply difficulty
    ctx.lootMult *= diff().lootMult;

    // temporary story buffs (from searching / lingering)
    if (state.flags.focusedTurns){ ctx.lootMult *= (1 + 0.10 * state.flags.focusedTurns); }
    if (state.flags.exhaustedTurns){ ctx.ambushDmgMult *= (1 + 0.08 * state.flags.exhaustedTurns); }

    ctx.weaponLevel = (state.gear?.weapon||0);
    ctx.armorLevel = (state.gear?.armor||0);

    // apply traits
    for (const t of state.traits){
      const trait = TRAITS.find(x=>x.id===t.id);
      if (trait?.mod) trait.mod(ctx);
    }
    return ctx;
  }

  function logEntry(text, meta=""){
    const log = $("log");
    const el = document.createElement("div");
    el.className = "entry";
    const m = document.createElement("div");
    m.className = "meta";
    m.innerHTML = `<span>${meta || ("Day " + state.day)}</span><span>${new Date().toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"})}</span>`;
    const t = document.createElement("div");
    t.className = "text";
    t.textContent = text;
    el.appendChild(m);
    el.appendChild(t);
    log.appendChild(el);
    log.scrollTop = log.scrollHeight;
    return el;
  }


  function ensureFour(options){
    const out = options.slice(0);
    while (out.length < 4){
      out.push({
        text: "谨慎观察（不冒险）",
        kind: "primary",
        req: ()=>true,
        resolve: ()=>{
          endTurn({ log:"你花时间观察周围的动静，确保安全后再行动。", delta:{ morale:+0, threat:+0, energy:-1 } });
        }
      });
    }
    return out.slice(0,4);
  }

  function logEventCard(title, intro, options){
    const el = logEntry(`${title}：${intro}`, `Day ${state.day} / 事件`);
    const opts = document.createElement("div");
    opts.className = "opts";
    options.forEach((o, idx)=>{
      const b = document.createElement("button");
      b.textContent = o.text;
      const ok = o.req ? !!o.req() : true;
      b.disabled = !ok;
      if (o.kind==="primary") b.classList.add("primary");
      if (o.kind==="danger") b.classList.add("danger");
      if (o.kind==="good") b.classList.add("good");
      b.onclick = () => {
        if (state.pendingChoice && state.pendingChoice !== el) return;
        state.pendingChoice = null;
        b.blur();
        // disable all buttons in this card after choice
        [...opts.querySelectorAll("button")].forEach(x=>x.disabled=true);
        o.resolve();
      };
      opts.appendChild(b);
    });
    el.appendChild(opts);
    state.pendingChoice = el;
  }

  function applyDelta(delta){
    // Record last delta for UI
    state.lastDelta = delta || {};
    const d = delta || {};
    for (const [k,v] of Object.entries(d)){
      if (typeof state[k] !== "number") continue;
      state[k] += v;
    }
    // clamps
    state.hp = clamp(state.hp, 0, state.maxHp);
    state.morale = clamp(state.morale, 0, state.maxMorale);
    state.energy = clamp(state.energy, 0, state.maxEnergy);
    state.food = Math.max(0, state.food);
    state.water = Math.max(0, state.water);
    state.ammo = Math.max(0, state.ammo);
    state.med = Math.max(0, state.med);
    state.scrap = Math.max(0, state.scrap);
    state.threat = Math.max(0, state.threat);

    if (state.hp <= 0 || state.morale <= 0){
      gameOver();
    }
  }

  function endTurn({log, delta, meta}){
    if (log) logEntry(log, meta || `Day ${state.day} / 结果`);
    if (delta) applyDelta(delta);

    // daily consumption (difficulty-based, with visible penalty when short)
    const { waterCost, foodCost } = dailyCosts();

    // apply consumption manually so we can detect shortages BEFORE clamping
    state.lastDelta = state.lastDelta || {};
    state.water -= waterCost;
    state.food  -= foodCost;
    state.lastDelta.water = (state.lastDelta.water || 0) - waterCost;
    state.lastDelta.food  = (state.lastDelta.food  || 0) - foodCost;

    let hpPenalty = 0;
    if (state.food < 0){
      const miss = -state.food;
      state.food = 0;
      const dmg = miss * diff().hungerDmg;
      hpPenalty += dmg;
      logEntry(`食物不足，你挨饿受损（-${dmg} 生命）。`, `Day ${state.day} / 饥饿`);
    }
    if (state.water < 0){
      const miss = -state.water;
      state.water = 0;
      const dmg = miss * diff().thirstDmg;
      hpPenalty += dmg;
      logEntry(`水不足，你严重脱水（-${dmg} 生命）。`, `Day ${state.day} / 脱水`);
    }
    if (hpPenalty > 0){
      state.hp -= hpPenalty;
      state.lastDelta.hp = (state.lastDelta.hp || 0) - hpPenalty;
      state.hp = clamp(state.hp, 0, state.maxHp);
      if (state.hp <= 0){ gameOver(); return; }
    }

    // threat drifts upward over time
    applyDelta({ threat: + (state.day % 2 === 0 ? 1 : 0) });


    // fatigue / energy drain per day (difficulty-based)
    const fat = diff().fatigue || 0;
    if (fat>0){
      state.energy -= fat;
      state.lastDelta.energy = (state.lastDelta.energy || 0) - fat;
      state.energy = clamp(state.energy, 0, state.maxEnergy);
    }

    // decay temporary flags
    if (state.flags.focusedTurns) state.flags.focusedTurns = Math.max(0, state.flags.focusedTurns-1);
    if (state.flags.exhaustedTurns) state.flags.exhaustedTurns = Math.max(0, state.flags.exhaustedTurns-1);

    // day advance
    state.day += 1;
    if (state.day % 5 === 0) state.zone += 1;

    render();
  }

  function luckBias(){
    // if lucky, reduce chance of worst outcomes a bit
    return state.flags.lucky ? 0.08 : 0;
  }

  // -----------------------------
  // Event Resolvers
  // -----------------------------
  function scavenge(ctx, {risk}){
    const base = risk==="high" ? 6 : 4;
    const variance = risk==="high" ? 8 : 5;

    // risk check
    const danger = (risk==="high" ? 0.35 : 0.18) + state.threat*0.02;
    const dangerRoll = r();
    const hit = dangerRoll < (danger - luckBias());

    const loot = Math.max(1, Math.floor((base + ri(variance)) * ctx.lootMult));
    const gain = splitLoot(loot);

    if (!hit){
      endTurn({
        log:`你搜到了可用物资：${formatGain(gain)}。`,
        delta: { ...gain, morale:+1, threat:+ (risk==="high" ? 1 : 0) }
      });
    } else {
      const dmg = Math.ceil((risk==="high"?6:4) * (0.6 + r()*0.8) * ctx.ambushDmgMult);
      endTurn({
        log:`你翻柜子时触发了响动！一只感染者扑来，你受伤（-${dmg} 生命），但仍带走了物资：${formatGain(gain)}。`,
        delta: { ...gain, hp:-dmg, morale:-1, threat:+2 }
      });
    }
  }

  function splitLoot(points){
    // distribute points into resources
    const buckets = ["food","water","ammo","scrap","med"];
    const gain = {food:0, water:0, ammo:0, scrap:0, med:0};
    for (let i=0;i<points;i++){
      const k = pick(buckets);
      gain[k] += 1;
    }
    // med rarer
    if (gain.med > 2) { gain.scrap += (gain.med-2); gain.med = 2; }
    return gain;
  }

  function formatGain(g){
    const parts = [];
    for (const k of ["food","water","ammo","med","scrap"]){
      if ((g[k]||0) > 0) parts.push(`${nameOf(k)}+${g[k]}`);
    }
    return parts.join("，") || "无";
  }

  function nameOf(k){
    return ({
      hp:"生命",
      morale:"士气",
      food:"食物",
      water:"水",
      ammo:"弹药",
      med:"医疗",
      scrap:"废料",
      threat:"威胁",
      zone:"区域"
    })[k] || k;
  }

  function combat(ctx, {style}){
    const enemy = 6 + state.zone*2 + Math.floor(state.threat*0.6);
    const sneakRate = clamp(0.45 + ctx.sneakBonus - state.threat*0.03, 0.08, 0.85);
    const escapeRate = clamp(0.35 + ctx.escapeBonus - state.threat*0.02, 0.05, 0.8);

    if (style==="shoot"){
      const needAmmo = Math.max(0, Math.ceil(enemy/3) - ctx.combatAmmoDiscount - (ctx.weaponLevel||0));
      if (state.ammo < needAmmo){
        endTurn({
          log:`你想开火，但弹药不够（需要${needAmmo}）。你被迫撤退，士气下降。`,
          delta:{ morale:-2, threat:+1 }
        });
        return;
      }
      const hurtRaw = Math.max(0, Math.floor((enemy/6) * (r()<0.5?1:2)));
      const hurt = Math.max(0, hurtRaw - (ctx.armorLevel||0));
      const hurtText = hurt>0 ? `受了点伤（-${hurt}）` : "几乎毫发无损";
      const loot = splitLoot(3 + ri(4));
      endTurn({
        log:`你消耗${needAmmo}弹清理了尸群。你${hurtText}，并搜到：${formatGain(loot)}。`,
        delta:{ ammo:-needAmmo, hp:-hurt, ...loot, morale:+1, threat:+1 }
      });
      return;
    }

    if (style==="sneak"){
      const ok = r() < (sneakRate + luckBias());
      if (ok){
        endTurn({
          log:`你压低呼吸，从阴影里绕开了尸群。虽然慢，但安全。`,
          delta:{ morale:+1, threat:+0 }
        });
      } else {
        const dmgRaw = Math.ceil((4 + state.zone) * (0.8 + r()*0.6));
        const dmg = Math.max(0, dmgRaw - (ctx.armorLevel||0));
        endTurn({
          log:`你潜行失败！被突然袭击，慌乱撤退（-${dmg} 生命）。`,
          delta:{ hp:-dmg, morale:-1, threat:+2 }
        });
      }
      return;
    }

    if (style==="run"){
      const ok = r() < (escapeRate + luckBias());
      if (ok){
        endTurn({
          log:`你拔腿就跑，鞋底拍打积水声在巷子里回响，但你甩开了它们。`,
          delta:{ morale:+0, threat:+1 }
        });
      } else {
        const dmgRaw = Math.ceil((6 + state.zone*2) * (0.9 + r()*0.6));
        const dmg = Math.max(0, dmgRaw - (ctx.armorLevel||0));
        endTurn({
          log:`你没跑掉，被抓伤（-${dmg} 生命）。你狼狈逃离，威胁上升。`,
          delta:{ hp:-dmg, morale:-2, threat:+3 }
        });
      }
      return;
    }
  }

  function trade(delta, text){
    endTurn({
      log: text,
      delta: { ...delta, morale:+1, threat:+0 }
    });
  }

  function mug(ctx){
    // high variance outcome
    const risk = 0.45 + state.threat*0.02;
    const bad = r() < (risk - luckBias());
    if (!bad){
      const loot = { food: 2+ri(3), water: 1+ri(3), ammo: 1+ri(3), scrap: 1+ri(3) };
      endTurn({
        log:`你成功压制了商人，夺走了补给：${formatGain(loot)}。但这事会传出去。`,
        delta:{ ...loot, morale:+1, threat:+4 }
      });
    } else {
      const dmg = Math.ceil((7 + state.zone) * (0.9 + r()*0.7) * ctx.ambushDmgMult);
      endTurn({
        log:`商人早有准备！你被反击（-${dmg} 生命），还丢了点物资。`,
        delta:{ hp:-dmg, food:-2, water:-1, morale:-2, threat:+5 }
      });
    }
  }

  function weather(ctx, {choice}){
    if (choice==="shelter"){
      endTurn({
        log:`你躲进一辆翻倒的公交车里等雨停。闷热、口渴、心烦。`,
        delta:{ water:-1, morale:-1, threat:+0 }
      });
    } else {
      const dmg = Math.ceil((3 + state.zone) * (0.7 + r()*0.8));
      endTurn({
        log:`你顶着酸雨赶路，皮肤刺痛（-${dmg} 生命）。但你推进了路线。`,
        delta:{ hp:-dmg, threat:+2, morale:+0 }
      });
    }
  }

  function trap(ctx, {choice}){
    if (choice==="disarm"){
      const ok = r() < (0.72 - state.threat*0.02 + luckBias());
      if (ok){
        const scrap = 2 + ri(3);
        endTurn({
          log:`你成功排雷，还拆到一些零件（废料+${scrap}）。`,
          delta:{ scrap:+scrap, morale:+1, threat:+1 }
        });
      } else {
        const dmg = Math.ceil((5 + state.zone) * (0.8 + r()*0.8) * ctx.ambushDmgMult);
        endTurn({
          log:`排雷失误！爆炸把你掀翻（-${dmg} 生命）。`,
          delta:{ hp:-dmg, morale:-2, threat:+3 }
        });
      }
    } else {
      const dmg = (r() < (0.45 + state.threat*0.02 - luckBias()))
        ? Math.ceil((6 + state.zone) * (0.9 + r()*0.8) * ctx.ambushDmgMult)
        : 0;
      endTurn({
        log:`你冲了过去。${dmg>0?`还是踩到了一枚（-${dmg} 生命）`:"侥幸没事"}。`,
        delta:{ hp:-dmg, morale: (dmg>0?-1:+1), threat:+2 }
      });
    }
  }

  // -----------------------------
  // Actions: Rest / Craft / Upgrade
  // -----------------------------
  function doRest(){
    if (state.pendingChoice) return;
    const ctx = ctxBase();
    const heal = ctx.restHeal;
    const morale = 2;
    const eGain = Math.max(3, Math.floor(state.maxEnergy*0.75));

    // resting restores energy significantly (so rest matters even if you are not hurt)
    endTurn({
      log:`你在废楼里睡了个浅觉，稍微恢复了状态（生命+${heal}，士气+${morale}，精力+${eGain}）。`,
      delta:{ hp:+heal, morale:+morale, energy:+eGain, threat:+0 }
    });
  }

  function doCraft(){
    if (state.pendingChoice) return;
    const ctx = ctxBase();

    const g = state.gear || (state.gear={weapon:0, armor:0});
    const maxW = 3 + (state.flags.forge ? 1 : 0);
    const maxA = 3 + (state.flags.forge ? 1 : 0);

    const baseRecipes = [
      {
        id:"ammo",
        name:"制造弹药",
        desc:"把零件压成可用子弹",
        kind:"good",
        unitCost: { scrap: Math.max(0, 2 - (ctx.craftScrapDiscount||0)) },
        unitGain: { ammo: state.flags.ammoCraft ? 6 : 5 }
      },
      {
        id:"med",
        name:"简易医疗包",
        desc:"止血、消毒、固定",
        kind:"good",
        unitCost: { scrap: Math.max(0, 3 - (ctx.craftScrapDiscount||0)) },
        unitGain: { med: (state.flags.medBoost ? 3 : 2) }
      },
      {
        id:"food",
        name:"应急口粮",
        desc:"热量补给",
        kind:"good",
        unitCost: { scrap: Math.max(0, 1 - (ctx.craftScrapDiscount||0)) },
        unitGain: { food: 4 }
      },
      {
        id:"water",
        name:"净水片",
        desc:"把脏水处理成可喝的水（小幅补水）",
        kind:"good",
        unitCost: { scrap: Math.max(0, 1 - (ctx.craftScrapDiscount||0)) },
        unitGain: { water: (state.flags.purifier ? 3 : 2) }
      },
    ];

    function craftMaxTimes(unitCost){
      let m = Infinity;
      for (const [k,v] of Object.entries(unitCost||{})){
        if (v<=0) continue;
        m = Math.min(m, Math.floor((state[k]||0)/v));
      }
      return (m===Infinity?0:m);
    }

    function openBatch(recipe){
      const maxTimes = craftMaxTimes(recipe.unitCost);
      const qs = [1,3,5].filter(x=>x<=maxTimes);
      if (!qs.includes(maxTimes) && maxTimes>0) qs.push(maxTimes);

      const costTxt = Object.entries(recipe.unitCost).map(([k,v])=>`${nameOf(k)}-${v}`).join("，");
      const gainTxt = formatGain(recipe.unitGain);
      const intro = `${recipe.desc}
单次：消耗 ${costTxt} → 获得 ${gainTxt}
可制造次数：${maxTimes}（当前废料：${state.scrap}）`;

      const opts = [];
      for (const q of qs){
        const totalCost = {};
        const totalGain = {};
        for (const [k,v] of Object.entries(recipe.unitCost)) totalCost[k]=v*q;
        for (const [k,v] of Object.entries(recipe.unitGain)) totalGain[k]=v*q;
        opts.push({
          text:`制造 x${q}（总消耗：${Object.entries(totalCost).map(([k,v])=>`${nameOf(k)}-${v}`).join("，")} → 总获得：${formatGain(totalGain)}）`,
          kind: recipe.kind,
          req: ()=> Object.entries(totalCost).every(([k,v])=> (state[k]||0) >= v),
          resolve: ()=>{
            const delta = { morale:+1, energy:-1 };
            for (const [k,v] of Object.entries(totalCost)) delta[k]=(delta[k]||0) - v;
            for (const [k,v] of Object.entries(totalGain)) delta[k]=(delta[k]||0) + v;
            applyDelta(delta);
            logEntry(`你批量完成了【${recipe.name}】x${q}。`, `Day ${state.day} / 制造`);
            render();
          }
        });
      }
      if (maxTimes<=0){
        opts.push({ text:"材料不足，无法制造", kind:"primary", req:()=>false, resolve:()=>{} });
      }
      opts.push({ text:"返回制造列表", kind:"primary", resolve: ()=> doCraft() });

      logEventCard(`制造：${recipe.name}`, intro, ensureFour(opts));
      render();
    }

    const listOpts = [];
    for (const r of baseRecipes){
      listOpts.push({
        text:`${r.name}（可批量）`,
        kind:r.kind,
        req: ()=> craftMaxTimes(r.unitCost) > 0 && state.energy>0,
        resolve: ()=> openBatch(r)
      });
    }

    // upgrades (single step)
    const armorCost = (state.flags.armorCheap ? (3 + (g.armor||0)*1) : (3 + (g.armor||0)*2));
    const weaponCost = (state.flags.armorCheap ? (3 + (g.weapon||0)*1) : (3 + (g.weapon||0)*2));

    listOpts.push({
      text:`升级护甲（Lv.${g.armor||0} → Lv.${Math.min(maxA,(g.armor||0)+1)}，消耗：废料-${armorCost}）`,
      kind:"primary",
      req: ()=> (g.armor||0) < maxA && state.scrap >= armorCost && state.energy>0,
      resolve: ()=>{
        applyDelta({ scrap:-armorCost, morale:+1, energy:-1 });
        g.armor = Math.min(maxA, (g.armor||0)+1);
        logEntry(`你升级了护甲（Lv.${g.armor}）。`, `Day ${state.day} / 制造`);
        render();
      }
    });
    listOpts.push({
      text:`升级武器（Lv.${g.weapon||0} → Lv.${Math.min(maxW,(g.weapon||0)+1)}，消耗：废料-${weaponCost}）`,
      kind:"primary",
      req: ()=> (g.weapon||0) < maxW && state.scrap >= weaponCost && state.energy>0,
      resolve: ()=>{
        applyDelta({ scrap:-weaponCost, morale:+1, energy:-1 });
        g.weapon = Math.min(maxW, (g.weapon||0)+1);
        logEntry(`你升级了武器（Lv.${g.weapon}）。`, `Day ${state.day} / 制造`);
        render();
      }
    });

    listOpts.push({ text:"取消（不制造）", kind:"primary", resolve: ()=>{ logEntry("你决定先不制造。", `Day ${state.day} / 制造`); render(); } });

    logEventCard(
      "制造",
      `你整理了一下零件。当前废料：${state.scrap}。提示：制造会消耗少量精力，但不消耗天数。`,
      ensureFour(listOpts)
    );
    render();
  }


  // -----------------------------
  // Tech Tree (stateful upgrades)
  // -----------------------------
  const TECH_TREE = [
    { id:"tech_water_saver", tier:1, name:"节水装置", cost:{scrap:3}, desc:"每日水消耗 -1（最低1）", prereq:[], apply:()=>{ state.flags.waterSaver=true; } },
    { id:"tech_rationing", tier:1, name:"口粮配给", cost:{scrap:3}, desc:"每日食物消耗 -1（最低1）", prereq:[], apply:()=>{ state.flags.rationing=true; } },
    { id:"tech_workbench", tier:1, name:"工作台", cost:{scrap:4}, desc:"制造更省废料（-1）", prereq:[], apply:()=>{ state.flags.craftScrapDiscount = (state.flags.craftScrapDiscount||0)+1; } },

    { id:"tech_purifier", tier:2, name:"过滤器", cost:{scrap:6}, desc:"净水片产出+1；探索更容易找到水源", prereq:["tech_water_saver"], apply:()=>{ state.flags.purifier=true; } },
    { id:"tech_medic", tier:2, name:"医疗整理", cost:{scrap:6}, desc:"医疗包产出+1", prereq:["tech_workbench"], apply:()=>{ state.flags.medBoost=true; } },
    { id:"tech_armory", tier:2, name:"护具改装", cost:{scrap:6}, desc:"护甲升级更便宜", prereq:["tech_workbench"], apply:()=>{ state.flags.armorCheap=true; } },

    { id:"tech_radio", tier:3, name:"无线电修复", cost:{scrap:9}, desc:"主线剧情分支更饱满（解锁额外章节节点）", prereq:["tech_purifier"], apply:()=>{ state.flags.radioFix=true; storyEnqueueMany(["st_radio_fix"]); } },
    { id:"tech_forge", tier:3, name:"简易锻造", cost:{scrap:9}, desc:"武器/护甲升级上限 +1（到 Lv.4）", prereq:["tech_armory"], apply:()=>{ state.flags.forge=true; } },
  ];

  function techOwned(id){ state.tech = state.tech || {}; return !!state.tech[id]; }
  function techCanBuy(n){
    if (techOwned(n.id)) return false;
    if (!n.prereq.every(p=>techOwned(p))) return false;
    return Object.entries(n.cost).every(([k,v])=>state[k]>=v);
  }
  function buyTech(n){
    for (const [k,v] of Object.entries(n.cost)) state[k]-=v;
    state.tech[n.id]=true;
    n.apply();
    logEntry(`你解锁了科技【${n.name}】。`, `Day ${state.day} / 科技`);
    render();
  }

  function doUpgrade(){
    if (state.pendingChoice) return;
    state.tech = state.tech || {};

    const lines = [
      "科技树（你的选择会影响后续剧情）",
      "Tier1：节水装置 / 口粮配给 / 工作台",
      "Tier2：过滤器 / 医疗整理 / 护具改装",
      "Tier3：无线电修复 / 简易锻造",
      "—— 可解锁项会根据前置与资源自动出现 ——"
    ];

    const opts = [];

    // available nodes first
    for (const n of TECH_TREE){
      if (!techOwned(n.id) && n.prereq.every(p=>techOwned(p))){
        const costTxt = Object.entries(n.cost).map(([k,v])=>`${nameOf(k)}-${v}`).join("，");
        opts.push({
          text: `${n.name}（${costTxt}）- ${n.desc}`,
          kind: "primary",
          req: ()=>techCanBuy(n),
          resolve: ()=>{ buyTech(n); }
        });
      }
    }

    // already owned summary
    const owned = TECH_TREE.filter(n=>techOwned(n.id)).map(n=>n.name);
    if (owned.length){
      opts.unshift({
        text: `已解锁：${owned.join("、")}`,
        kind:"good",
        req: ()=>false,
        resolve: ()=>{}
      });
    }

    if (opts.length===0){
      opts.push({ text:"暂无可解锁科技（需要更多废料或前置）", kind:"primary", req:()=>false, resolve:()=>{} });
    }

    opts.push({ text:"关闭", kind:"primary", resolve: ()=>{ logEntry("你把图纸收好。", `Day ${state.day} / 科技`); render(); } });

    logEventCard("科技树", lines.join("\n"), opts);
    render();
  }

  // -----------------------------
  // Turn: Next Event
  // -----------------------------
  function nextDayEvent(){
    if (state.pendingChoice) return;

    const ctx = ctxBase();

    // Story: linked narrative that reacts to previous choices
    const sn = storyPickNode();
    if (sn){
      logEventCard(sn.title, sn.intro, storyOptions(sn, ctx));
      render();
      return;
    }

    // Pick event with weights depending on threat/zone
    const weights = EVENT_TEMPLATES.map(e=>{
      let w = 1;
      if (e.type==="story") return 0;
      if (e.type==="combat") w += state.threat*0.25 + state.zone*0.2;
      if (e.type==="scavenge") w += 0.6;
      if (e.type==="trade") w += Math.max(0, 0.8 - state.threat*0.08);
      if (e.type==="trap") w += state.threat*0.2;
      if (e.type==="weather") w += 0.3 + state.zone*0.1;
      return w;
    });

    const ev = weightedPick(EVENT_TEMPLATES, weights);
    const options = ensureFour(ev.options(ctx));

    logEventCard(ev.title, ev.intro, options);
    render();
  }

  function weightedPick(items, weights){
    const total = weights.reduce((a,b)=>a+b,0);
    let x = r()*total;
    for (let i=0;i<items.length;i++){
      x -= weights[i];
      if (x <= 0) return items[i];
    }
    return items[items.length-1];
  }

  function shuffle(arr){
    for (let i=arr.length-1;i>0;i--){
      const j = Math.floor(r()*(i+1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  // -----------------------------
  // Zombie progress UI (flavor)
  // -----------------------------
  function zombieStatus(){
    // purely UI flavor: based on day+threat
    const p = clamp((state.day*1.8 + state.threat*3) / 100, 0, 1);
    const pct = Math.floor(p*100);
    let stage = "低";
    let impact = "零星感染者活动。";
    if (pct >= 25){ stage="中"; impact="街区危险显著上升。"; }
    if (pct >= 50){ stage="高"; impact="成群游荡，补给点变少。"; }
    if (pct >= 75){ stage="极高"; impact="大范围失守，战斗频繁。"; }
    return { pct, stage, impact };
  }

  // -----------------------------
  // UI Rendering
  // -----------------------------
  function render(){
    $("seedBadge").textContent = `seed: ${state.seedText} · 难度: ${diff().name}`;
    $("runBadge").textContent = `Day ${state.day} · Zone ${state.zone}`;
    $("threatPill").textContent = `威胁：${state.threat}`;

    const z = zombieStatus();
    $("zombiePill").textContent = `僵尸进度：${z.pct}%（${z.stage}）`;

    const dc = dailyCosts();
    const warn = (state.food < dc.foodCost || state.water < dc.waterCost) ? '（警告：明天可能短缺）' : '';
    $("hintLine").textContent = `${z.impact} 明天消耗：食物 ${dc.foodCost} / 水 ${dc.waterCost} ${warn}`;

    const consumeEl = $("consumeLine");
    if (consumeEl) consumeEl.textContent = `每日消耗：食物 ${dc.foodCost} / 水 ${dc.waterCost}`;

    // Difficulty UI
    const sel = $("difficultySelect");
    if (sel){
      sel.value = state.settings?.difficulty || 'normal';
      const desc = $("difficultyDesc");
      if (desc) desc.textContent = diff().desc;
    }

    // Gear UI
    const g = state.gear || {weapon:0, armor:0};
    const gearLine = $("gearLine");
    if (gearLine) gearLine.textContent = `装备：武器 Lv.${g.weapon} · 护甲 Lv.${g.armor}`;
    const stats = [
      {k:"生命", v:`${state.hp}/${state.maxHp}`, key:"hp"},
      {k:"士气", v:`${state.morale}/${state.maxMorale}`, key:"morale"},
      {k:"精力", v:`${state.energy}/${state.maxEnergy}`, key:"energy"},
      {k:"食物", v:state.food, key:"food"},
      {k:"水", v:state.water, key:"water"},
      {k:"弹药", v:state.ammo, key:"ammo"},
      {k:"医疗", v:state.med, key:"med"},
      {k:"废料", v:state.scrap, key:"scrap"},
      {k:"威胁", v:state.threat, key:"threat"},
    ];

    const grid = $("statsGrid");
    grid.innerHTML = "";
    const last = state.lastDelta || {};
    for (const s of stats){
      const el = document.createElement("div");
      el.className = "stat";
      const d = last[s.key];
      const deltaBadge = (typeof d === "number" && d !== 0)
        ? `<span class="delta ${d>0?"good":"bad"}">${d>0?"+":""}${d}</span>`
        : `<span class="delta">${" "}</span>`;
      el.innerHTML = `
        <div class="k">${s.k}</div>
        <div class="v"><span>${s.v}</span>${deltaBadge}</div>
      `;
      // low resource highlighting
      if (s.key === "food" || s.key === "water"){
        const val = Number(state[s.key]);
        if (val === 0) el.classList.add("zero");
        else if (val <= 2) el.classList.add("low");
      }
      grid.appendChild(el);
    }

    const traits = $("traitsList");
    traits.innerHTML = "";
    if (!state.traits.length){
      const p = document.createElement("span");
      p.className = "pill muted";
      p.textContent = "（无）";
      traits.appendChild(p);
    } else {
      for (const t of state.traits){
        const def = TRAITS.find(x=>x.id===t.id);
        const p = document.createElement("span");
        p.className = "pill accent";
        p.title = def?.desc || "";
        p.textContent = def ? `${def.name}` : t.id;
        traits.appendChild(p);
      }
    }

    // buttons availability
    $("btnNext").disabled = !!state.pendingChoice;
    $("btnRest").disabled = !!state.pendingChoice;
    $("btnCraft").disabled = !!state.pendingChoice;
    $("btnUpgrade").disabled = !!state.pendingChoice;

    // auto game over check
    if (state.hp <= 0 || state.morale <= 0){
      $("btnNext").disabled = true;
      $("btnRest").disabled = true;
      $("btnCraft").disabled = true;
      $("btnUpgrade").disabled = true;
    }
  }

  // -----------------------------
  // Game flow
  // -----------------------------
  function startNewRun(seedText){
    state = DEFAULTS();
    if (seedText) state.seedText = seedText;
    rng = mulberry32(hashSeed(state.seedText));

    // roll traits (2 random)
    const pool = shuffle([...TRAITS]).slice(0,2);
    state.traits = pool.map(t=>({id:t.id}));
    state.lastDelta = {};
    state.pendingChoice = null;

    $("log").innerHTML = "";
    logEntry("你从避难所醒来。外面风里夹着灰，远处的城市像一具巨大的尸体。", "开局");
    logEntry(`你的特性：${pool.map(x=>x.name).join("、")}。活下去。`, "开局");
    render();
  }

  function gameOver(){
    state.pendingChoice = null;
    logEntry("你撑不下去了。世界没有为你停下。", "GAME OVER");
    render();
  }

  // -----------------------------
  // Save/Load
  // -----------------------------
  function exportSave(){
    const data = JSON.stringify(state);
    const blob = new Blob([data], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `save_${state.seedText}_day${state.day}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }
  function importSave(){
    const inp = document.createElement("input");
    inp.type="file";
    inp.accept="application/json";
    inp.onchange = async () => {
      const file = inp.files?.[0];
      if (!file) return;
      const text = await file.text();
      try{
        const obj = JSON.parse(text);
        // minimal validation
        if (!obj || typeof obj !== "object" || !("day" in obj)) throw new Error("bad save");
        state = obj;
        rng = mulberry32(hashSeed(state.seedText || randomSeedText()));
        state.pendingChoice = null;
        state.lastDelta = {};
        $("log").innerHTML = "";
        logEntry("已载入存档。你回到那一天。", "系统");
        render();
      }catch(e){
        alert("存档格式不对。");
      }
    };
    inp.click();
  }

  // -----------------------------
  // Wire UI
  // -----------------------------
  $("btnNext").onclick = nextDayEvent;
  $("btnRest").onclick = doRest;
  $("btnCraft").onclick = doCraft;
  $("btnUpgrade").onclick = doUpgrade;
  $("btnNewRun").onclick = () => startNewRun();
  $("btnSave").onclick = exportSave;
  $("btnLoad").onclick = importSave;


  const diffSel = $("difficultySelect");
  if (diffSel){
    diffSel.onchange = () => {
      state.settings = state.settings || {};
      state.settings.difficulty = diffSel.value;
      logEntry(`难度已切换为：${diff().name}。`, "系统");
      render();
    };
  }


  // Show any runtime error on screen (so buttons failing is diagnosable)
  window.addEventListener("error", (e)=>{
    try{
      const box=document.createElement("div");
      box.style.position="fixed"; box.style.left="12px"; box.style.right="12px"; box.style.bottom="12px";
      box.style.background="rgba(255,95,109,.12)"; box.style.border="1px solid rgba(255,95,109,.35)";
      box.style.color="var(--text)"; box.style.padding="10px 12px"; box.style.borderRadius="12px";
      box.style.fontFamily="var(--mono)"; box.style.zIndex="99999";
      box.textContent = "脚本错误：" + (e.message||"unknown") + "（请把这句发给我）";
      document.body.appendChild(box);
    }catch(_){}
  });

  window.addEventListener("keydown", (e)=>{
    if (e.target && ["INPUT","TEXTAREA"].includes(e.target.tagName)) return;
    if (e.key==="n" || e.key==="N") nextDayEvent();
    if (e.key==="r" || e.key==="R") doRest();
    if (e.key==="c" || e.key==="C") doCraft();
    if (e.key==="u" || e.key==="U") doUpgrade();
  });

  // Start
  startNewRun();

})();
</script>
</body>
</html>
